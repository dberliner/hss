// SPDX-License-Identifier: GPL-2.0+
/**
 * @file hss_proxy.c
 * @brief Implementation of the host proxy for HSS. These functions
 *	are called by the USB system when a message is completed.
 */

#include <linux/circ_buf.h>
#include <linux/kthread.h>
#include <linux/socket.h>
#include <linux/net.h>
#include <linux/workqueue.h>
#include <net/sock.h>
#include "hss.h"
#include "hss-proxy.h"
#include "hss-sockets.h"
#include "hss-usb.h"
#include "hss-ring.h"

/* NOTE: Size must be a power of 2 for circ_buf */
static const int READ_CACHE_SIZE = 1<<13; /* 8kb */

struct hss_proxy_context {
	u16 proxy_id;
	struct workqueue_struct *proxy_wq;
	struct workqueue_struct *proxy_data_wq;
	struct rhashtable *socket_table;
	void *usb_context;
	struct circ_buf read_cache ____cacheline_aligned_in_smp;
};

struct work_data_t {
	struct work_struct work;
	struct hss_proxy_context *context;
	struct hss_packet data;
};

struct listen_data {
	int sock_id;
	struct hss_proxy_context *context;
};

/* Forward declarations */
static void hss_proxy_process_cmd(struct work_struct *work);
static void hss_proxy_process_data(struct work_struct *work);
int hss_proxy_listen_socket(void *param);

static u16 hss_dev_counter;
static atomic_t g_msg_id;

/**
 * hss_proxy_init - Initializes an instance of the HSS proxy
 * for a HSS USB driver and returns a pointer to the new instance.
 *
 * @context A pointer to the USB context to use on future calls
 *
 * Returns: A pointer to the new proxy instance.
 *
 * Notes:
 * All proxy API functions expect a `context` pointer generated by this
 * function to know which instance to run on.
 */
void *hss_proxy_init(void *usb_context)
{
	int ret;
	struct hss_proxy_context *context = NULL;

	/* Make the name large enough to hold the largest possible value */
	char name[sizeof("hss_data_wq_4294967296")];

	struct workqueue_struct *wq = NULL;
	struct workqueue_struct *data_wq = NULL;
	int dev = hss_dev_counter++;

	/* Name and allocate the workqueue */
	snprintf(name, sizeof(name), "hss_wq_%d", dev);
	wq = create_workqueue(name);
	if (!wq)
		goto exit;

	snprintf(name, sizeof(name), "hss_data_wq_%d", dev);
	data_wq = create_workqueue(name);
	if (!data_wq)
		goto free_wq;

	context = kmalloc(sizeof(*context), GFP_KERNEL);

	if (!context)
		goto free_data_wq;
	context->proxy_id = dev;
	context->proxy_wq = wq;
	context->proxy_data_wq = data_wq;
	context->usb_context = usb_context;

	context->read_cache.buf = kmalloc(READ_CACHE_SIZE, GFP_KERNEL);
	if (!context->read_cache.buf)
		goto free_context;
	context->read_cache.head = 0;
	context->read_cache.tail = 0;

	/* Initialize the proxy */
	ret = hss_socket_mgr_init(&context->socket_table);
	if (ret)
		goto free_read_cache;

	goto exit;

free_read_cache:
	kfree(context->read_cache.buf);
free_context:
	kfree(context);
	context = NULL;
free_data_wq:
	destroy_workqueue(data_wq);
free_wq:
	destroy_workqueue(wq);
exit:
	return context;
}

void hss_proxy_destroy(void *context)
{
	struct hss_proxy_context *proxy = context;

	kfree(proxy->read_cache.buf);
	destroy_workqueue(proxy->proxy_wq);
	hss_socket_mgr_destroy(proxy->socket_table);
}

static int hss_family_to_host(enum hss_family dev_fam)
{
	int host_fam = -1;

	if (dev_fam == HSS_FAM_IP)
		host_fam = PF_INET;
	else if (dev_fam == HSS_FAM_IP6)
		host_fam = PF_INET6;

	return host_fam;
}

static enum hss_proto hss_protocol_to_host(enum hss_proto dev_proto)
{
	int host_proto = -1;

	if (dev_proto == HSS_PROTO_TCP)
		host_proto = IPPROTO_TCP;
	else if (dev_proto == HSS_PROTO_UDP)
		host_proto = IPPROTO_UDP;

	return host_proto;
}

static enum hss_type hss_type_to_host(enum hss_type dev_type)
{
	int host_type = -1;

	if (dev_type == HSS_TYPE_STREAM)
		host_type = SOCK_STREAM;
	else if (dev_type == HSS_TYPE_DGRAM)
		host_type = SOCK_DGRAM;

	return host_type;
}

/**
 * hss_proxy_process_open - Process an OPEN packet
 *
 * @packet The packet sent by the device
 * @dev The device ID requesting this operation
 * @ack The ACK packet to populate
 *
 */
void hss_proxy_process_open(struct hss_packet *packet, u16 dev,
	struct hss_packet *ack, struct hss_proxy_context *context)
{

	int ret;
	int family, type, protocol;
	struct hss_payload_open payload;

	hss_get_payload_open(packet, &payload);

	/* Translate the HSS parameters to ones the socket interface */
	family = hss_family_to_host(payload.addr_family);
	if (family < 0) {
		ret = -EINVAL;
		goto fill_ack;
	}

	protocol = hss_protocol_to_host(payload.protocol);
	if (protocol < 0) {
		ret = -EINVAL;
		goto fill_ack;
	}

	type = hss_type_to_host(payload.type);
	if (type < 0) {
		ret = -EINVAL;
		goto fill_ack;
	}
	ret = hss_socket_create(payload.handle, family, type, protocol,
		context->socket_table);

fill_ack:
	/* If creation succeded return created ID without the device */
	hss_packet_fill_ack_open(packet, ack, ret, payload.handle);
}

/**
 * hss_proxy_process_connect - Process an CONNECT packet
 *
 * @packet The packet sent by the device
 * @dev The device ID requesting this operation
 * @ack The ACK packet to populate
 *
 * Performs an CONNECT operation based on an incoming HSS packet.
 */
void hss_proxy_process_connect(struct hss_packet *packet, u16 dev,
	struct hss_packet *ack, struct hss_proxy_context *context)
{
	int ret;
	struct hss_payload_connect_ip payload;
	struct hss_packet_hdr hdr; 
	int id;

	hss_get_header(packet, &hdr);
	hss_get_payload_connect(packet, &payload);
	id = hdr.sock_id;

	switch (payload.family) {
	case HSS_FAM_IP:
		pr_info("Connecting IPv4");
		ret = hss_socket_connect_in4(
			id,
			(char *)&(payload.addr.ip4.ip_addr),
			sizeof(payload.addr.ip4.ip_addr),
			payload.port,
			0,
			context->socket_table);
		break;
	case HSS_FAM_IP6:
		pr_info("Connecting IPv6");
		ret = hss_socket_connect_in6(
			id,
			(char *)&(payload.addr.ip6.ip_addr),
			sizeof(payload.addr.ip6.ip_addr),
			payload.port,
			payload.addr.ip6.flow_info,
			payload.addr.ip6.scope_id,
			0,
			context->socket_table);
		break;
	default:
		pr_info("Connecting inval");
		ret = -EINVAL;
		break;
	}
	hss_packet_fill_ack_connect(packet, ack, ret);

	/* Start reading from the socket if we are connected */
	if (!ret) {
		struct task_struct *new_thread;
		/* Spawned thread is expected to free */
		struct listen_data *params =
			kmalloc(sizeof(struct listen_data), GFP_KERNEL);
		params->sock_id = id;
		params->context = context;

		new_thread = kthread_create(
			hss_proxy_listen_socket,
			params,
			"hss_sk_%d",
			id);
		if (new_thread)
			wake_up_process(new_thread);
	}
}

/**
 * Helper funciton to form a CLOSE packet for a given socket and send it
 *
 * @sock_id The ID of the sock to close
 * @usb_context A pointer to the USB context
 *
 * Note: Close packets have no payload so the send size will always be
 * sizeof(struct hss_packet_hdr). Msg is expected to be of sufficient length.
 */
static void hss_send_close(
	int sock_id,
	void *usb_context)
{
	struct hss_packet close_packet;
	char *proxy_cmd_buf;

	/* Send a close to the device */
	hss_packet_fill_close(&close_packet, sock_id, atomic_inc_return(&g_msg_id));
	proxy_cmd_buf = hss_get_ack_buf(usb_context);
	hss_packet_to_buf(&close_packet, proxy_cmd_buf, HSS_COPY_FIELDS);
	hss_cmd_out(usb_context, proxy_cmd_buf, HSS_FIXED_LEN_CLOSE);
}

/**
 * Fills and sends a TRANSMIT packet for a given sock. Msg must be a unfilled
 * HSS packet header with the payload appended afterwards.
 *
 * @msg The HSS packet to send, already have payload appended
 * @payload_len The length of the payload
 * @usb_context A pointer to the USB context
 *
 * Note: To avoid excessive memory copying callers should allocate a send
 * buffer large enough for both the header and payload data then write the
 * actual payload data starting at offset sizeof(struct hss_packet_hdr)
 */
static void hss_send_transmit(
	struct hss_packet *msg,
	int payload_len,
	int sock_id,
	void *usb_context)
{
	int bulk_ret;
	struct hss_packet pkt;
	int packet_len = payload_len + HSS_FIXED_LEN_TRANSMIT;

	hss_packet_fill_transmit(&pkt, sock_id, NULL, payload_len, atomic_inc_return(&g_msg_id));
	hss_packet_to_buf(&pkt, (char *)msg, HSS_COPY_FIELDS);

	bulk_ret = hss_bulk_out(usb_context, msg, packet_len);

	/* Bulk_out should only return send length requested */
	if (bulk_ret != packet_len)
		pr_err("%s bulk_out send %d, returned %d\n",
			__func__, packet_len, bulk_ret);
}

/* Continually listen to a socket and pass its data over USB */
int hss_proxy_listen_socket(void *param)
{
	struct listen_data *ld = param;
	int max_msg_len = XAPRC00X_BULK_OUT_BUF_SIZE;
	int max_read_len = max_msg_len - HSS_FIXED_LEN_TRANSMIT;
	struct hss_packet *msg = kzalloc(max_msg_len, GFP_KERNEL);
	int sock_read_len;
	void *usb_context = ld->context->usb_context;

	while (1) {
		/* Read data from our socket. To save on excessive memory copies we will write
		 * to the location it will be on the outgoing packet. */
		sock_read_len = hss_socket_read(
			ld->sock_id,
			(char *)msg + HSS_FIXED_LEN_TRANSMIT,
			max_read_len,
			0,
			ld->context->socket_table);

		/* Close and exit on a zero-read */
		if (sock_read_len <= 0) {
			hss_send_close(
				ld->sock_id,
				usb_context);
			break;
		}

		hss_send_transmit(
			msg,
			sock_read_len,
			ld->sock_id,
			usb_context);

		/* Zero out the packet (not the payload, though) */
		memset(msg, 0, sizeof(*msg));
	}
	kfree(msg);
	kfree(param);
	return sock_read_len;
}

/**
 * hss_proxy_process_close - Process an CLOSE packet
 *
 * @packet The packet sent by the device
 * @dev The device ID requesting this operation
 * @ack The ACK packet to populate
 *
 * Performs an CLOSE operation based on an incoming HSS packet.
 */
void hss_proxy_process_close(struct hss_packet *packet, u16 dev,
	struct hss_packet *ack, struct hss_proxy_context *context)
{
	struct hss_packet_hdr hdr;

	hss_get_header(packet, &hdr);

	hss_socket_close(hdr.sock_id, context->socket_table);

	/* Close ACKs do not contain status data. */
	hss_packet_fill_ack(&hdr, ack);
}

/**
 * hss_proxy_rcv_cmd - Receives and begins processing an HSS packet
 *
 * @context A pointer to the proxy instance
 * @packet A pointer to the packet to process
 * @packet_len The length of the packet
 *
 * Notes:
 * Packet can be modified or freed after this function returns.
 * This function may be called in an atomic context.
 */
void hss_proxy_rcv_cmd(char *packet,
	int packet_len, void *context)
{
	struct work_data_t *newwork;
	struct hss_proxy_context *proxy_ctx =
		(struct hss_proxy_context *) context;

	/* Allocate for a work_data_t that can fit the largest possible CMD packet */
	newwork = kmalloc(sizeof(struct work_data_t) + 64 - HSS_HDR_LEN, GFP_ATOMIC);

	newwork->context = proxy_ctx;

	/* Copy the header so the entire packet can be evaluated */
	if (packet_len < HSS_HDR_LEN)
		return;
	hss_packet_from_buf(&newwork->data, packet, HSS_COPY_HDR);

	/* Make sure the length sent is correct and copy any given payload */
	if (packet_len != newwork->data.hdr.payload_len + HSS_HDR_LEN ||
			newwork->data.hdr.payload_len > 64 - HSS_HDR_LEN)
		return;
	else if (newwork->data.hdr.payload_len > 0 )
		hss_packet_from_buf(&newwork->data, packet, HSS_COPY_FIELDS);

	INIT_WORK(&newwork->work, hss_proxy_process_cmd);
	queue_work(proxy_ctx->proxy_wq, &newwork->work);
}

/**
 * hss_proxy_rcv_bulk - Receives and begins processing an HSS packet
 *
 * @context A pointer to the proxy instance
 * @packet A pointer to the packet to process
 * @packet_len The length of the packet
 *
 * Notes:
 * Packet can be modified or freed after this function returns.
 * This function may be called in an atomic context.
 * Other threads may modify ring->tail during this operation.
 */
int hss_proxy_rcv_data(void *data, int len, void *context)
{
	struct work_data_t *newwork;
	struct hss_proxy_context *proxy_ctx =
		(struct hss_proxy_context *) context;
	struct circ_buf *ring = &proxy_ctx->read_cache;
	int did_copy;

	did_copy = hss_ring_write(ring, READ_CACHE_SIZE, data, len);

	newwork = kmalloc(sizeof(struct work_data_t), GFP_ATOMIC);

	if(newwork) {
		newwork->context = proxy_ctx;

		INIT_WORK(&newwork->work, hss_proxy_process_data);
		queue_work(proxy_ctx->proxy_data_wq, &newwork->work);
	} else {
		pr_err("%s could not allocate work item.\n", __func__);
	}

	return did_copy;
}

/**
 * hss_proxy_run_host_cmd -
 * Helper function for hss_proxy_process_cmd
 *
 * @packet The packet to process
 * @ack The ACK packet to reply with
 * @proxy_context The proxy context
 *
 * Returns: A buffer containing an ACK message or NULL if no ACK.
 *
 * Notes:
 * Any returned ACK buffer is owned by the USB driver and should not be freed
 * or used outside hss_proxy_process_cmd.
 */
static struct hss_packet *hss_proxy_run_host_cmd(
	struct hss_packet *packet,
	struct hss_proxy_context *context)
{
	int dev = context->proxy_id;
	struct hss_packet *ack = kmalloc(sizeof(*ack) + 64, GFP_KERNEL);

	switch (packet->hdr.opcode) {
	case HSS_OP_OPEN:
		hss_proxy_process_open(packet, dev, ack, context);
		break;
	case HSS_OP_CONNECT:
		hss_proxy_process_connect(packet, dev, ack, context);
		break;
	case HSS_OP_CLOSE:
		hss_proxy_process_close(packet, dev, ack, context);
		break;
	case HSS_OP_ACK:
	case HSS_OP_ACKDATA:
	case HSS_OP_SHUTDOWN:
	case HSS_OP_TRANSMIT:
	default:
		pr_err("%s default %d\n", __func__, packet->hdr.opcode);
		ack = NULL;
		break;
	}
	return ack;
}


static void hss_proxy_send_ack(struct hss_packet *packet, struct hss_proxy_context *proxy_context)
{
	char *proxy_cmd_buf;

	proxy_cmd_buf =
		hss_get_ack_buf(proxy_context->usb_context);

	/* Copy the fixed part of the ACK */
	hss_packet_to_buf(packet, proxy_cmd_buf, HSS_COPY_FIELDS);

	/* Copy the arbitrary payload if applicable */
	if (packet->hdr.payload_len + HSS_HDR_LEN > HSS_FIXED_LEN_ACK)
		memcpy(
				proxy_cmd_buf + HSS_FIXED_LEN_ACK,
				&packet->hss_payload_none,
				packet->hdr.payload_len - HSS_FIXED_LEN_ACK + HSS_HDR_LEN);

	/* Send the ACK over USB */
	hss_cmd_out(proxy_context->usb_context, proxy_cmd_buf,
		HSS_HDR_LEN + packet->hdr.payload_len);
}

/**
 * hss_proxy_process_cmd - Bottom half of hss_proxy_rcv_cmd
 *
 * @work Work item to process
 *
 * Notes:
 * Work struct is expected to be of type work_data_t and be tailed with
 * `work->packet_len` bytes for the actual packet.
 */
static void hss_proxy_process_cmd(struct work_struct *work)
{
	struct work_data_t *work_data;
	struct hss_proxy_context *proxy_context;
	struct hss_packet *packet;
	struct hss_packet *ack;

	work_data = (struct work_data_t *) work;
	proxy_context = work_data->context;
	packet = (struct hss_packet *)&work_data->data;

	ack = hss_proxy_run_host_cmd(packet, proxy_context);

	if (ack) {
		hss_proxy_send_ack(ack, proxy_context);
		kfree(ack);
	}

	kfree(work);
}

static int hss_proxy_transmit_send(
	struct circ_buf *ring,
	struct hss_packet_hdr *packet_hdr,
	struct hss_proxy_context *context)
{
	char *payload;
	struct hss_ring_section section;
	int ret = 1;

	section = hss_consumer_section(ring, READ_CACHE_SIZE,
		packet_hdr->payload_len);
	payload = ring->buf + section.start;

	if (section.start > -1) {
		/* Write the sequential portion of the payload */
		hss_socket_write(
			packet_hdr->sock_id,
			payload,
			section.len,
			context->socket_table);

		/* If any of the payload wraps around the buffer */
		hss_socket_write(
			packet_hdr->sock_id,
			ring->buf,
			section.wrap,
			context->socket_table);

		hss_ring_consume(ring, READ_CACHE_SIZE, section);

		ret = 0;
	}
	return ret;
}

/**
 * hss_proxy_transmit_and_consume - Handles inbound (from device)
 * data type commands
 *
 * @packet The packet to process
 * @context the hss proxy context
 *
 * Notes:
 * Returns a newly allocated ACK or NULL. Caller must free
 */
static struct hss_packet *hss_proxy_transmit_and_consume(
	struct hss_packet_hdr *packet_hdr,
	struct circ_buf *ring,
	struct hss_proxy_context *context)
{
	struct hss_packet *ack;

	switch (packet_hdr->opcode) {
	case HSS_OP_TRANSMIT:
		ack = kmalloc(sizeof(struct hss_packet), GFP_KERNEL);
		hss_proxy_transmit_send(ring, packet_hdr, context);

		/* TODO Positive flow codes */
		hss_packet_fill_ack(packet_hdr, ack);
		ack->ack.code = HSS_E_SUCCESS;
		break;
	default:
		ack = NULL;
		pr_err("%s default op %d", __func__, packet_hdr->opcode);
		break;
	}
	return ack;
}

/**
 * hss_proxy_process_data - Handles inbound (from device)
 * data type packets
 *
 * @work The work struct, expected type `struct hss_proxy_context`
 *
 * Notes: Other threads may modify ring->head during this operation.
 */
static void hss_proxy_process_data(struct work_struct *work)
{
	struct hss_proxy_context *proxy_context;
	struct circ_buf *ring;
	int packet_len;
	int circ_cnt;
	struct hss_packet *ack = NULL;
	struct hss_packet packet;
	char cont_hdr_space[HSS_HDR_LEN];
	struct hss_ring_section section;

	/* Unpack the work data */
	proxy_context = ((struct work_data_t *) work)->context;
	ring = &proxy_context->read_cache;

	/* Get the section we can read from the buffer */
	section = hss_consumer_section(
		ring,
		READ_CACHE_SIZE,
		HSS_HDR_LEN);

	/* If theres not a headers worth of data in the buffer */
	if (section.start == -1)
		goto exit;

	/* Copy the header to a contiguous buffer */
	memcpy(cont_hdr_space, ring->buf + section.start, section.len);
	memcpy(((char *) cont_hdr_space) + section.len, ring->buf, section.wrap);

	/* Convert the contiguous buffer to a readable packet */
	hss_packet_from_buf(&packet, cont_hdr_space, HSS_COPY_HDR);

	/* Compare the amount of data ready to be read against the stated length of the packet */
	circ_cnt = CIRC_CNT(
		READ_ONCE(ring->head),
		READ_ONCE(ring->tail),
		READ_CACHE_SIZE);
	packet_len = packet.hdr.payload_len + HSS_HDR_LEN;

	/* Do not continue if the entire payload hasn't arrived */
	if (packet_len > circ_cnt)
		goto exit;

	/* If the entire packet can be read consume the header */
	hss_ring_consume(ring, READ_CACHE_SIZE, section);

	/* Transmit and consume the payload data */
	ack = hss_proxy_transmit_and_consume(&packet.hdr, ring, proxy_context);

	/* Send an ACK if applicable */
	if (ack) {
		hss_proxy_send_ack(ack, proxy_context);
		kfree(ack);
	}
exit:
	kfree(work);
}
